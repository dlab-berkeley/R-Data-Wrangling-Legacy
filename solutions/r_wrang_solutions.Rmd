## Challenge 1 

Here is a dataset inspired by an Economist/YouGov Poll about the importance of unemployment in the United States. 

```{r}
challenge_1 <- tibble(
  issue_importance = c("Very Important", "Somewhat Important",
                       "Not very Important", "Unimportant"),
  `18-29` = c(.59, .28, .08, .05),
  `30-44` = c(.66, .27, .06, .02),
  `45-64` = c(.69, .28, .03, .01),
  `65+` = c(.7, .27, .02, .01)
)

head(challenge_1)
```

Answer the following: 

1. How many observations are in the data set?

*16. While they are only 4 rows in this table, there are four categories of issue importance and four age groups. 4x4 = 16 total observations.*

2. How many columns are in the data set?

```{r}
ncol(challenge_1)
```

3. Is every column a variable?

*No! This data is messy. The first column is a variable that contains the universe of issue importance answers. However, the next five columns are all instances of the variable age.*


## Challenge 2 

Which one of these do you think is the *tidy* format?

```{r}
wide <- data.frame(
  name = c("Wilbur", "Petunia", "Gregory"),
  time1 = c(67, 80, 64),
  time2 = c(56, 90, 50),
  time3 = c(70, 67, 101)
)
wide

long <- data.frame(
  name = c("Wilbur", "Petunia", "Gregory", "Wilbur", "Petunia", "Gregory", "Wilbur", "Petunia", "Gregory"),
  time = c(1, 1, 1, 2, 2, 2, 3, 3, 3),
  heartrate = c(67, 80, 64, 56, 90, 50, 70, 67, 10)
)
long
```

*The first dataframe (the "wide" one) would not be considered tidy because values for a given variable (i.e. heartrate) are spread across multiple columns.*

## Challenge 3

Create a new data frame object called `cats_and_dogs` that filters the `animals` data frame for all observations for which the animal type is a cat or a dog. Use the pipe operator to chain the functions together. 

```{r}
cats_and_dogs <- animals %>% 
  filter(Type == "Cat"|Type == "Dog")
```
  
## Challenge 4

Let's put the verbs we've learned so far into action all at once. Answer the question "What are the total number of dog rescues for each borough?" by making a data frame called `borough_dog_rescues` and arranging the rows by borough in alphabetical order. 

```{r}
## Your Code here 
borough_dog_rescues <- animals %>% 
  group_by(Borough)%>%
  filter(Type == "Dog")%>%
  count(Type)%>%
  arrange(Borough)

```

## Challenge 5

Create a data frame that considers the average rescue cost, median rescue cost, and standard deviation for bird rescues for each property category year. Save the result of your workflow into a data frame object called `bird_stats`


```{r, include=F}
#YOUR CODE HERE
bird_stats <- animals %>% 
  group_by(PropertyCategory, Year)%>%
  filter(Type == "Bird")%>%
  summarise(median_cost = median(RescueCost, na.rm = T),
            avg_cost = mean(RescueCost, na.rm = T), 
            sd_cost = mean(RescueCost, na.rm = T),
            .groups = "drop_last")

```


## Challenge 6

Add a column to the gapminder dataset that contains the continent's total population of each observation in a given year. For example, if the first observation was Afghanistan in 1952, the new column would contain the population of Asia in 1952. 

```{r}
gapminder <- gapminder %>% 
  group_by(continent, year) %>% 
  mutate(continent_pop = sum(pop))
``` 

  
## Challenge 7 

Use dplyr to: (a) add a column called `gdpPercap_diff` that contains the difference between the observation's `gdpPercap` and the mean `gdpPercap` of the continent in that year, (b) arrange the data frame by the column you just created, in descending order (so that the relatively richest country/years are listed first)

```{r}
gapminder_gdpPercap_diff <- gapminder %>%  
  group_by(continent, year) %>% 
   mutate(mean_continent_gdp = mean(gdpPercap),
          gdpPercap_diff = gdpPercap - mean_continent_gdp) %>% 
  arrange(desc(gdpPercap_diff))
```
  
  
## Challenge 8

1. We have provided the code below to answer Challenge 7. Ungroup the results, then subset them to select only the `country`, `year`, and `gdpPercap_diff` columns. Put it in a wide format so that countries are rows and years are columns.

```{r}
## Starter code 
gapminder_gdpPercap_diff <- gapminder %>%  
  group_by(continent, year) %>% 
   mutate(mean_continent_gdp = mean(gdpPercap),
          gdpPercap_diff = gdpPercap - mean_continent_gdp)

gapminder_wide <- gapminder_gdpPercap_diff %>% 
  ungroup() %>% 
  select(country, year, gdpPercap_diff) %>% 
  pivot_wider(
    names_from = year,
    values_from = gdpPercap_diff
  )
```

2. Now, turn the data frame above back into the long format with three columns: `country`, `year`, and `gdpPercap_diff`.

```{r}
gapminder_long <- gapminder_wide %>% 
  pivot_longer(
    cols = c(-country),
    names_to = "year",
    values_to = "gdpPercap_diff"
  )
```

## Challenge 9 

The IGS poll also contains a question broken down by region (`cal_region.csv`). Build a pipeline that reads and tidies the data. For extra practice, make a similar graph to display the results. 

```{r}
## Full pipe here 
read_csv(here("data/cal_region.csv"))%>% 
  pivot_longer(-leaving, 
               names_to = "age", 
               values_to = "percent_agreement")%>% 
  ggplot(aes(x = leaving, y = percent_agreement, fill=age))+
  geom_col(position = 'dodge')+
  xlab("Moving Consideration Level")+
  ylab("Percent Agreement")+
  scale_fill_discrete(type = "viridis")+
  ggtitle("Californians Consideration to Leaving the State")

```

## Challenge 10 

Edit the workflow presented above to split on the fifth character. Use `mutate` to replace the incorrect values with corrected and capitalized names.  

```{r}
## Here's a solution that takes advantage of stringr capabilities
## There are multiple ways to solve this problem
birds %>% 
  pivot_longer(!c(county,year), 
               names_to = "sight",
               values_to = "n",
               values_drop_na = TRUE)%>%
  separate(sight, c("type", "location"),sep = 5)%>%
  mutate(type = str_replace_all(type, "warbl", "warbler")%>%str_to_title(),
         location = if_else(str_detect(location, "Ne"), "Nest", "Air"))
```